
[{"content":"","externalUrl":null,"permalink":"/arch-install-guide/","section":"Arch Install Guide","summary":"","title":"Arch Install Guide","type":"arch-install-guide"},{"content":" B C D F G I K L M P R S U bootloader The bootloader is a small program that runs after your system firmware (UEFI or BIOS) and before your operating system. Its job is to load the kernel of the OS into memory and start it. An example of this is GRUB. compatibility-layer A compatibility layer is a piece of software that converts an interaction between Software A and Software B into an interaction between Software A and Software C. Wine is an example of a compatibility layer, because it translate Windows NT kernel calls into Linux kernel calls. compilation Compilation is the act of turning source code into machine code. distro A \u0026ldquo;distro\u0026rdquo; (or Linux distribution) is a bundle of software including a fully-configured copy of the Linux kernel, and other software which allow applications to run. For example, Arch Linux is a distro that comes bundled with the GNU software collection, systemd, and pacman. filesystem A filesystem is a set of rules as to how files should be organised and accessed on a partition - this usually deletes everything on that partition (if there\u0026rsquo;s anything on there to begin with). Think of the partition as a piece of paper. Formatting is like drawing the guide lines, margin and setting the page layout so you can write inside of it properly, of course, for the piece of paper to be useful, everything on it needs to be rubbed out before you can do so. format To format a partition means to prepare it for storing files by creating a filesystem on it. gnu GNU, is a collection of software that allows you to fully interact with your computer. Linux was created after GNU as it has no kernel, which is essential for a computer to run. greeter A greeter is the login screen. It asks for a username and password so that you can then access your desktop. It is provided by the display manager, which is responsible for starting the graphics server. The graphics server is responsible for managing graphical elements on your computer, like drawing windows. init An init process is the first process your computer loads when powering on. It is the parent of all processes - it sets them up and manages them. It does things like running background processes, configures hardware et cetera, and makes sure that the computer has come to the state where it\u0026rsquo;s ready for you to use. It stays running the entire time that your computer is on, managing processes as I have stated before and handling errors if they crash. Arch Linux uses systemd, which is an entire suite of software, not just an init system, doing things such as logging and networking. It\u0026rsquo;s easy to manage as everything is in one place, and provides fast boot-up times. iso file An iso file is, generally speaking, an \u0026ldquo;image\u0026rdquo; (or snapshot) of what would be written to something like a CD or drive. However, within the context of this guide, an ISO file is a single file that contains all the data needed to install an operating system. Arch Linux is installed using a live ISO, meaning that the operating system that boots from it is a complete and fully-functional operating system. However, this is only used as an intermediate stage to get Arch Linux installed on to your drive. kernel A kernel is the middleman between programs and hardware. An example of this is the NT kernel, which is what Windows uses. linux Linux is a Unix-like kernel released in 1991 by Linus Torvalds. machine code Machine code (also known as a \u0026lsquo;binary executable\u0026rsquo;, or just \u0026lsquo;binary\u0026rsquo;) is what computers can actually understand and run (or \u0026ldquo;execute\u0026rdquo;). mirror A mirror is essentially a duplicate copy of some data on a master server (a server that the data was originally uploaded on). Mirrors are kept for two reasons, to have a copy in case something goes wrong on the master server (or, \u0026ldquo;redundancy\u0026rdquo;) and speed. Mirrors are set up on Linux distros to make download speeds faster, because, put simply, the closer you are to a server, the less time it takes to upload and download data. This is why the mirrorlist exists, as really slow download speeds can time out, meaning that your computer will give up after some period of waiting. package manager A package manager is a collection of software that automates the process of installing, updating and deleting software on a computer in a consistent manner. Arch Linux uses pacman (not to be confused with the \u0026rsquo;80s arcade game) which is a rolling release package manager, meaning that software is not released as regular, big updates every once in a while, but rather, small and continuous updates delivered frequently. partition A partition is an explicitly defined section of your drive. Each partition on your computer can be managed separately, meaning all of the data on one partition is completely different from the data on another. This is useful for keeping data crucial for your system to run from other data like documents. root directory Not to be confused with the root user. The root directory is the furthest back in a file structure you can go. It is where all the branches created from files and folders on your computer originate from. It holds important folders such as /boot/ and /home/. root user Not to be confused with the root directory. The root user is the most powerful user on your computer capable of performing any task with zero restrictions. Regular users can\u0026rsquo;t and shouldn\u0026rsquo;t be able to run everything as root, because it\u0026rsquo;s too easy to, for example, delete something important that is essential for your OS to function. This is why it\u0026rsquo;s good practice to make a user separate from the root user, and add a password to it so you think more about what you type in to your shell. shell The shell is the text interface that allows you to interact with your computer that surrounds the kernel to hide its intricate details. signature A signature (or a \u0026lsquo;hash signature\u0026rsquo;, or just \u0026lsquo;hash\u0026rsquo;) is a random string of letters assigned to a file that serves as its unique digital fingerprint. A good hashing algorithm (such as SHA-256) produces a unique string of letters for each input it is given, if they are different. This means that it is impossible for a file to be tampered with without producing an extremely different hash. This is why it is important to check the signature of each file you download off the internet with the one given by the software\u0026rsquo;s publisher. source code Source code is what computer programmers write to make computers do things. It needs to be converted into machine code before it can be run (or \u0026ldquo;executed\u0026rdquo;). Programs can either be distributed as source code, meaning that the user has to compile it themselves, or they can be distributed as machine code where no compilation is needed. Both approaches have their upsides and downsides. Source code distributions means that the user has to compile the code, meaning that your program suddenly has a learning curve attached to it. Machine code distributions mean that your program now only works for one kind of machine and operating system (for example, if you compile your program on an x64 Linux machine, the machine code binary will only work other x64 Linux machines). swap Linux swap is either a file or partition on your drive. It is used as a section of your disk that can store data in RAM even when the computer is off (for hibernation, which is important for laptop users) or be used in case RAM runs out. Even if you are not on a laptop and have a sufficient amount of RAM, some programs rely solely on swap, so make create swap space regardless. This guide will not create a swapfile, but rather, a swap partition to keep the swap data separate from everything else. unix-like Unix is an operating system family that started off at AT\u0026amp;T. It became very influential within academic circles, leading to large-scale adoption by start-up companies, leading Unix to fragment into much smaller, similar but mostly mutually incompatible OSes. Among these are MacOS and the BSD operating systems (FreeBSD, OpenBSD, NetBSD .etc). An operating system is said to be Unix-like if it behaves like a Unix operating system. For this reason, Linux is generally considered to be Unix-like. The reason why Linux is Unix-like and not Unix is because it is commonly paired with GNU, which stands for \u0026ldquo;GNU\u0026rsquo;s Not Unix\u0026rdquo;. ","externalUrl":null,"permalink":"/arch-install-guide/glossary/","section":"Arch Install Guide","summary":"Terms you may come across when reading the documentation. This contains a list defining all of these terms.","title":"Glossary","type":"arch-install-guide"},{"content":"Arch Linux is a rolling release Linux distribution, meaning that software updates are released as small continuous updates rather than big updates delivered at regular intervals, like Windows.\nThis makes Arch Linux great for gaming, as new updates to GPU drivers and such are installable as soon as they are available.\nHowever, there is a bit of a learning curve when it comes to Arch, especially when it comes to installing it and any apps through pacman. However, don\u0026rsquo;t let this scare you, as this guide will cover those things in-depth.\nImportant terminology # Important terminology can be found on the glossary here. Make sure to have a good read of it so you have a good understanding of what I\u0026rsquo;m trying to across in the guide.\nWhat this guide will not cover (as of now) # All the points below are unplanned as of now - but may come sometime in the future!\nHow to install any unofficial ports of Arch Linux (e.g. Artix, Arch Linux ARM, Arch Linux 32 .etc). How to dual-boot any operating system with Linux How to configure desktop environments. How to configure shells How to configure greeters Requirements # You must have basic technical understanding (i.e. know what \u0026lsquo;hardware\u0026rsquo; and \u0026lsquo;software\u0026rsquo; mean) and you must have an AMD64 computer (or \u0026lsquo;x86_64\u0026rsquo;) which your computer likely is.\nSwitching to Arch from Windows (or want a dual-boot setup)? Hit the Windows Key and R on your keyboard at the same time, a dialog like the below should appear on the bottom left of your screen: In it, type cmd.exe, and hit enter. A window like the below should appear: In that, enter the below command:\necho %PROCESSOR_ARCHITECTURE% If it returns AMD64, you\u0026rsquo;re all good to go.\nSwitching to Arch from MacOS or another Linux distro? On MacOS, open the \u0026ldquo;Terminal\u0026rdquo; application from Finder.\nOn any Linux distribution, open your terminal application. This could be kitty, alacritty, konsole, yakuake .etc.\nIn the shell, enter the below command:\nuname -m If it returns x86_64, you\u0026rsquo;re all good to go.\nGuide notation # \u0026lt;...\u0026gt; means that there\u0026rsquo;s something between the text shown in the guide, which have been omitted to narrow the guide\u0026rsquo;s focus, or because the program lists something specific to your computer .etc\nAnything else between angled brackets means that you should substitute it with what the text reads, for example, \u0026lt;your drive\u0026gt; means that you should substitute \u0026lt;your drive\u0026gt; for the drive that you want to install Arch Linux on to.\nAny text after hashtags, where the hashtag is not the first character in the command, explain the command you are running and may be omitted when you type it in.\nThis means that if you see the below in the guide:\nsfdisk --delete \u0026lt;your drive\u0026gt; # make a backup of your drive before running this command Assuming your drive is /dev/sda, you would type the below command into the shell:\nsfdisk --delete /dev/sda Prompts # # before a command means that you need the command as root in order to execute it. The safest (and simplest) was to do so is to replace the hashtag with sudo. If you are in the Arch Live ISO, you can simply omit the hashtag when typing in the command.\n$ before a command means that the command can just be run normally. Just omit the dollar sign when typing in the command.\nAny other prompt before a command means that you should not be typing in the command into your shell, but rather, you should be typing it into some other program, such as iwctl, which has the prompt: [iwd]#\nWarning\nMake sure you read everything thoroughly instead of blindly copying and pasting commands into the Arch Live ISO or the terminal. Any loss of data as a result of this recklessness is no fault to the author of this guide\n","externalUrl":null,"permalink":"/arch-install-guide/introduction/","section":"Arch Install Guide","summary":"Outlines what the guide will and will not go through, requirements for installing Arch and guide notation","title":"Introduction","type":"arch-install-guide"},{"content":" Reboot into firmware interface # Firstly, have a BitTorrent client installed on your computer. If you don\u0026rsquo;t, install one from here.\nThen, visit the official Arch Linux website to find the magnet link required to download the file. Once you find the magent link, click on it and the torrenting process should start shortly.\nOnce the torrenting process has completed, you should see a file named archlinux-2025.05.01-x86_64.iso in the downloads folder on your computer.\nTake this file and use some program such as Rufus (Windows only), BalenaEtcher or Ventoy to write the ISO image to an appropriate medium, such as a CD, SD card or USB thumbdrive.\nOnce you have written the ISO file to your computer, click on one of the collapsible sections below and follow the instructions given, depending on what browser you\u0026rsquo;re starting off from:\nSwitching from Windows to Arch? Hit the Windows Key and R on your keyboard at the same time, a dialog like the below should appear on the bottom left of your screen: In it, type cmd.exe, and hit enter. A window like the below should appear: In that, enter the below command:\n$ shutdown /r /fw /t 1 You should see some kind of screen with options to configure how your computer runs. What exactly you see depends on your hardware manufacturer, which you should search up, as having a photo for each firmware options screen would make this page unnecessarily long.\nFind some option with a name similar to boot options, and select the storage medium that contains the Arch Linux live environment.\nSwitching to Arch on a Mac? Turn off your computer and hold the Option key as you turn on your Mac.\nYou may see a screen like the below. If your computer boots normally, you held Option too late, so try again with better timing. Use the arrow keys on your keyboard to navigate to the option labelled EFI Boot and press Enter on your keyboard to select it.\nSwitching to Arch from another Linux distro? Open your terminal application, this could be kitty, alacritty, konsole, yakuake .etc.\nIn your shell, type the below command:\n# systemctl reboot --firmware-setup Once you have booted from your storage medium, select Arch Linux install medium (x86_64, UEFI), or Arch Linux install medium (x86_64, UEFI) with speech if you are visually impaired.\nYou should then see something resembling the following screen:\nChange font (on HiDPI monitors) # If you have a HiDPI monitor, it may be in your best interest to change the terminal font to a larger one since the text may be small and difficult to read.\nLoad a larger terminal font as shown below:\nsetfont ter-132b Load keymaps # A keymap is how your keyboard is laid out. It defines the keys you use and where they are placed on the keyboard. To find a list of all the keymaps available for your language/region, run the below command:\nlocalectl list-keymaps To search for a keymap, use the following command, replacing \u0026lt;search_term\u0026gt; with the code for your language, country, or layout:\nlocalectl list-keymaps | grep -i \u0026lt;search_term\u0026gt; Once you\u0026rsquo;ve found a keymap that matches your physical keyboard\u0026rsquo;s layout, run the below command.\nloadkeys \u0026lt;keymap\u0026gt; ","externalUrl":null,"permalink":"/arch-install-guide/booting_into_the_live_iso/","section":"Arch Install Guide","summary":"Informs you on how to boot into the Arch Live ISO and basic things like setting up keymaps and font sizes in the Live ISO","title":"Booting the Arch Live ISO","type":"arch-install-guide"},{"content":"Now that you have entered the Arch live ISO, you\u0026rsquo;ll need to connect to the internet.\nYou\u0026rsquo;ll need to connect to the internet in order to download essential programs, such as the kernel.\nThere are two main ways to connect to the internet, and one is a lot more common than the other.\nThe first method is a fixed broadband, which is where your modem is connected to the wider-area network using a cable.\nThe second method is a mobile broadband modem, where your modem is connected to the wider-area network using a cellular network (like the one your phone uses, 4G and 5G).\nIf you are unsure, you likely have a fixed broadband.\nIf you normally connect via an ethernet cable, you may skip this section after plugging it in.\nConnecting to a fixed broadband network Firstly, enter the below command:\n# iwctl This will change your shell prompt from:\nroot@archiso ~ # to:\n[iwd]# In this new prompt, the following command will show a list of your network devices (interface that provides some network functionality, e.g. connecting to the internet using Wi-Fi) and their adapters (the actual network hardware):\n[iwd]# device list Find your network device (and its adapter, if applicable) from the list given, and turn them on using the commands below:\n[iwd]# device \u0026lt;network device\u0026gt; set-property Powered on [iwd]# device \u0026lt;network adapter\u0026gt; set-property Powered on Once you have done that, scan for networks using the command below:\n[iwd]# station \u0026lt;network device\u0026gt; scan Take note that the above command will not output anything. To actually output a list of all the networks around your computer, run the following command:\n[iwd]# station \u0026lt;network device\u0026gt; get-networks Then, to connect to the network of your choice, use the below command:\n[iwd]# station \u0026lt;network device\u0026gt; connect \u0026lt;network SSID\u0026gt; If the network is hidden (i.e. it doesn\u0026rsquo;t show up in the list of networks, but you want to connect to it anyway), use the below command:\n[iwd]# station \u0026lt;network device\u0026gt; connect-hidden \u0026lt;network SSID\u0026gt; Enter your network password when prompted and hit enter.\nOnce finished, simply enter:\n[iwd]# exit Connecting to a mobile broadband modem Enable the modemmanager service, as shown below:\n# systemctl enable modemmanager.service --now modemmanager is the software that allows you to connect to your mobile broadband modem.\nTo get a list of all the mobile broadband modems around you, run the below command:\n# mmcli -L Look for /org/freedesktop/ModemManager1/Modem/[modem index] (where your modem index is the unique number representing your modem)\nConnect to your modem by running:\n# mmcli -m \u0026lt;modem index\u0026gt; --simple-connect=\u0026#34;apn=\u0026lt;your modem\u0026#39;s APN\u0026gt;\u0026#34; Your APN is your modem\u0026rsquo;s Access Point Name and will have been given to you by your ISP.\nIf your modem requires a username and password, you can specify them like so:\\\nmmcli -m \u0026lt;modem index\u0026gt; --simple-connect=\u0026#34;apn=\u0026lt;your modem\u0026#39;s APN\u0026gt;,user=\u0026lt;username\u0026gt;,password=\u0026lt;password\u0026gt;\u0026#34; Test that your internet connection actually works, as shown below:\nping -c 4 archlinux.org ","externalUrl":null,"permalink":"/arch-install-guide/connect_to_the_internet/","section":"Arch Install Guide","summary":"Informs you on how to connect to the internet in the Arch Live ISO","title":"Connect to the internet","type":"arch-install-guide"},{"content":"Now that the Arch live ISO has been connected to the internet, you\u0026rsquo;ll need to divide your disk up into partitions.\nThis guide will show you how to create four different partitions:\nA boot partition, which holds the files that load the kernel and other necessary things for your computer to enter a state where it can be used. A swap partition, which holds swap space A root partition, which holds your root directory A home partition, which holds your user account and anything that might be stored on to it, like images and documents. Warning\nThe guide assumes you want to delete everything on your drive.\nMake sure you have backed up everything important on it before you continue with this guide.\nPartitioning the drive # Firstly, enter the gdisk shell (which is a program that helps you manage modern drives), as shown below:\n# gdisk \u0026lt;your drive\u0026gt; This will change your shell prompt from:\nroot@archiso ~ # to\nCommand (? for help): Enter \u0026ldquo;expert mode\u0026rdquo; as shown below (expert mode allows you to do more things with your drive):\nCommand (? for help): x Which changes your prompt to this:\nExpert command (? for help): Delete everything on your drive using the below command:\nExpert command (? for help): z This will bring up a warning message to confirm this is absolutely, positively what you want to do.\nEnter \u0026ldquo;y\u0026rdquo; to confirm.\nAbout to wipe out GPT on {your drive}. Proceed (Y/N): y Another message will pop up:\nGPT data structures destroyed! You may now proceed to partition the disk using fdisk or other utilities. Blank out MBR? (Y/N): Enter \u0026ldquo;y\u0026rdquo; to confirm the above. This will overwrite the first 512 bytes of your drive so that any bootloader you install later on will not get confused.\nAfter clearing your drive, gdisk will return you to your regular shell prompt (as seen below):\nroot@archiso ~ # Return to the gdisk shell by entering:\n# gdisk \u0026lt;your drive\u0026gt; Changing your prompt back to:\nCommand (? for help): You will want to create partitions for Arch Linux to live on. This can easily be done by entering the following commands.\nFirstly, you want to create a boot partition (as shown below):\nCommand (? for help): n gdisk will then ask you what number you want to give this partition, as shown below.\nPartition number (1-128, default 1): Simply press enter when it prompts you with the above. Here, gdisk just gives the partition the next unused number.\nNext, gdisk will ask you where you want the partition to begin.\nFirst sector (\u0026lt;...\u0026gt;, default=2048) or {+-}size{KMGTP}: Press enter to begin the partition at the first bit of free space it can allow.\nThen, gdisk will ask how big you want the partition to be (as shown below).\n1 gigabyte is more than enough for a boot partition.\nLast sector (\u0026lt;...\u0026gt;, default=\u0026lt;...\u0026gt;) or {+-}size{KMGTP}: +1G It will then ask you what type of partition you want to create.\nWe want to create a modern boot partition. So enter \u0026lsquo;EF00\u0026rsquo; as shown below.\nCurrent type is \u0026#39;Linux filesystem\u0026#39; Hex code or GUID (L to show codes, Enter = 8300): EF00 It will then return you to:\nCommand (? for help): You will want to set a \u0026ldquo;label\u0026rdquo; for this partition - a unique name to help you identify this partition.\nFor the purposes of this guide, it will be labelled as \u0026ldquo;boot\u0026rdquo;\nCommand (? for help): c gdisk will then ask you which partition you want to label. Select partition 1\nPartition number (1-1): 1 Then it will ask you to set the label for this partition. Enter boot\nEnter name: boot This time, you will want to create a swap partition.\nCreate a new partition as shown below.\nCommand (? for help): n gdisk will then ask you what number you want to give this partition, as shown below.\nHit enter to use the default.\nPartition number (2-128, default 2): Next, gdisk will ask you where you want the partition to begin.\nHit enter to use the default.\nFirst sector (\u0026lt;...\u0026gt;, default=\u0026lt;...\u0026gt;) or {+-}size{KMGTP}: Then, gdisk will ask you how big you want the partition to be.\nThe size of this partition will depend on how big your RAM is. Make your swap partition twice the size of your RAM, or use 16 gigabytes, whichever is smaller.\nThe below is for if your RAM is 16 gigabytes or larger.\nLast sector (\u0026lt;...\u0026gt;, default=\u0026lt;...\u0026gt;) or {+-}size{KMGTP}: +16G It will then ask you what type of partition you want to create.\nWe want to create a swap partition. So enter \u0026lsquo;8200\u0026rsquo; as shown below.\nCurrent type is \u0026#39;Linux filesystem\u0026#39; Hex code or GUID (L to show codes, Enter = 8300): 8200 Now, you will want to name this partition swap.\\\nCommand (? for help): c Enter the number for the swap partition (2):\nPartition number (1-2): 2 Then name it swap\nEnter name: swap Now, you want to create a partition for your system files to live in (your root partition)\nCommand (? for help): n Press enter to the below prompts to use their defaults:\nPartition number (3-128, default 3): And:\nFirst sector (\u0026lt;...\u0026gt;, default=\u0026lt;...\u0026gt;) or {+-}size{KMGTP}: Now for the size of your root partition. If your drive is small (less than 128GB), press enter to the below prompt to use up the rest of your drive. This will mean that your system files and things like documents will live in the same space on your drive.\nLast sector (\u0026lt;...\u0026gt;, default=\u0026lt;...\u0026gt;) or {+-}size{KMGTP}: If your drive is 128GB in size or higher, then give your root partition 40GB in space.\nLast sector (\u0026lt;...\u0026gt;, default=\u0026lt;...\u0026gt;) or {+-}size{KMGTP}: +40G Simply press enter when given the below prompt, to tell your computer that this is just a regular filesystem partition.\nCurrent type is \u0026#39;Linux filesystem\u0026#39; Hex code or GUID (L to show codes, Enter = 8300): Now, you will want to name this partition root.\nCommand (? for help): c Enter 3 to the below prompt to select the root partition.\nPartition number (1-3): 3 Then, name it root.\nEnter name: root If you have a large drive You also want to create a home partition for the files that are not boot, not root and not swap to live in.\nCommand (? for help): n Press enter to the below prompts to use their defaults:\nPartition number (4-128, default 4): And:\nFirst sector (\u0026lt;...\u0026gt;, default=\u0026lt;...\u0026gt;) or {+-}size{KMGTP}: And the below (which tells gdisk to make the partition use up the rest of your drive):\nLast sector (\u0026lt;...\u0026gt;, default=\u0026lt;...\u0026gt;) or {+-}size{KMGTP}: And:\nCurrent type is \u0026#39;Linux filesystem\u0026#39; Hex code or GUID (L to show codes, Enter = 8300): You will want to name this partition home.\nCommand (? for help): c Enter 4 to the below prompt to select the home partition.\nPartition number (1-4): 4 Then name it home\nEnter name: home These partitions have been created, but have not actually been written to the drive.\ngdisk has only kept track of them in memory.\nTo actually write them to drive, enter the below command:\nCommand (? for help): w gdisk will confirm with you to ensure that you want to write these partitions to your drive.\nEnter y to confirm these changes.\nFinal checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING PARTITIONS!! Do you want to proceed? (Y/N): y You should then see the following message:\nOK; writing new GUID partition table (GPT) to \u0026lt;your drive\u0026gt; The operation has completed successfully Then you will be returned to the shell prompt (see below)\nroot@archiso ~ # Formatting partitions # Now that these partitions have been created, it is now time to make them actually useable.\nTo do this, you will have to format the partitions.\nFor most users, there are two filesystems that you can format your root (and home, if applicable) partition(s) to: btrfs and ext4.\nBtrfs offers snapshots and checksumming. Snapshots are like freeze-frames of your entire filesystem so that if you screw something up, you can easily restore your files to how they were to some point in time before you screwed things up.\nChecksumming just ensures that your data hasn\u0026rsquo;t been maliciously tampered with.\next4 doesn\u0026rsquo;t have these things, but it is quite fast and is the most common filesystem you will find on Linux.\nCheck that your partitions are correct by typing in the below command:\n# lsblk Format the boot partition, as shown below:\n# mkfs.fat -F32 /dev/disk/by-partlabel/boot Then, format the swap partition, as shown below:\n# mkswap /dev/disk/by-partlabel/swap If you want to encrypt your drive If you want to encrypt your drive, namely your root and home partitions, you will have to set up LUKS encryption, which this guide will go over.\nFirstly, ensure that your swap and boot partitions have been formatted.\nThen, start by encrypting your root partition, as shown below:\n# cryptsetup luksFormat /dev/disk/by-partlabel/root cryptsetup will give you a warning, and ask for confirmation before encrypting your drive.\nTo confirm, simply type YES in all caps as shown below.\nWARNING! ======== This will overwrite data on /dev/disk/by-partlabel/root irrevocably. Are you sure? (type \u0026#39;yes\u0026#39; in capital letters): YES cryptsetup will then ask you to set a passphrase. You should set a strong passphrase, preferably with a range of lower and upper case letters, numbers and punctuation. Make sure it is memorable too, because if you do not remember this, your root partition will permanently inaccessible.\nEnter passphrase: Then, it will ask you to verify this passphrase:\nVerify passphrase: Then, it will start encrypting your root partition, which may take a while.\nThen, you will want to encrypt your home partition.\n# cryptsetup luksFormat /dev/disk/by-partlabel/home cryptsetup will ask you for a passphrase, this can be the same as the passphrase you used for your root partition.\nEnter passphrase: Then, it will ask you to verify this passphrase:\nVerify passphrase: Then, it will start encrypting your home partition, which may take a while.\nNow, in order to install anything on to your root and home partitions, you will have to open them, as shown below:\n# cryptsetup open /dev/disk/by-partlabel/root cryptroot It will then ask you for your passphrase:\nEnter passphrase for /dev/disk/by-partlabel/root: Do the same for your home partition:\n# cryptsetup open /dev/disk/by-partlabel/home crypthome It will then ask you for your passphrase:\nEnter passphrase for /dev/disk/by-partlabel/home: Now that the root and home partitions have been opened, it is time to format them. Then, format the root partition, as shown below:\n# mkfs.btrfs /dev/mapper/crypthome -f OR, do not run the below command if you have run the one above, or vice versa\n# mkfs.ext4 -F /dev/mapper/crypthome If you have created a home partition, go ahead and format it.\n# mkfs.btrfs /dev/mapper/crypthome -f OR, do not run the below command if you have run the one above, or vice versa\n# mkfs.ext4 -F /dev/mapper/crypthome Once you have done all of the above, go ahead and skip to If you have encrypted your root and home partitions under Mounting partitions\nThen, format the root partition, as shown below:\n# mkfs.btrfs /dev/disk/by-partlabel/root -f OR, do not run the below command if you have run the one above, or vice versa.\n# mkfs.ext4 -F /dev/disk/by-partlabel/root If you have created a home partition, go ahead and format it.\n# mkfs.btrfs /dev/disk/by-partlabel/home -f OR, do not run the below command if you have run the one above, or vice versa.\n# mkfs.ext4 -F /dev/disk/by-partlabel/home Mounting partitions # For the partitions to be accessible to the Arch ISO, you need to mount them, which means to make them an accessible location on the Arch ISO.\nIf you have encrypted your root and home partitions Start by mounting the root partition:\n# mount /dev/mapper/cryptroot /mnt Then, mount the swap partition:\n# swapon /dev/disk/by-partlabel/swap Then, mount the boot partition:\n# mount -m /dev/disk/by-partlabel/boot /mnt/boot Finally, mount the home parititon:\n# mount -m /dev/mapper/crypthome /mnt/home Once you\u0026rsquo;ve finished all of the above, you\u0026rsquo;ve finished with this page of the guide. Move on with the next page.\nTo do this, start by mounting the root partition.\n# mount /dev/disk/by-partlabel/root /mnt Then mount your swap partition:\n# swapon /dev/disk/by-partlabel/swap Then the boot partition:\n# mount -m /dev/disk/by-partlabel/boot /mnt/boot And finally, the home partition:\n# mount -m /dev/disk/by-partlabel/home /mnt/home ","externalUrl":null,"permalink":"/arch-install-guide/drive_partitioning/","section":"Arch Install Guide","summary":"Informs you on what partitions to make, how to make them, and how to format and mount them","title":"Partitioning the drive","type":"arch-install-guide"},{"content":"Now that the internet and partitions have been fully sorted out, make sure that you get the faster download speeds possible.\nEnabling parallel downloads # Edit the pacman.conf file using the command below:\n# nano /etc/pacman.conf And uncomment the following line (meaning, remove the hashtag preceding the line):\n#ParallelDownloads = 5 So that it becomes:\nParallelDownloads = 5 This single line means that, instead of downloading each package one at a time, it will downloads five at once.\nHit Ctrl+W then Enter to save. Then hit Ctrl+Q to exit out of Nano.\nSetting up the mirrorlist # To create the mirrorlist, run the following command\nreflector -c \u0026lt;your country\u0026gt; -a 12 -p https --sort rate --save /etc/pacman.d/mirrorlist -c specifies the country that you live in. This is so that the mirrors have a low ping.\n-a specifies the \u0026ldquo;age\u0026rdquo; of the mirrors. The \u0026ldquo;age\u0026rdquo; is how long the mirrors have gone without being updated. A lower \u0026ldquo;age\u0026rdquo; normally means that the mirror gets updated more frequently.\n-p specifies the \u0026ldquo;protocol\u0026rdquo; of the mirrors, which means, how the packages are downloaded. Specifying \u0026ldquo;HTTPS\u0026rdquo; here means that your downloads are kept secure (i.e. not tampered with during the download).\n--sort specifies how the mirrors should be sorted. You will want to sort them by how fast the download rates are (for obvious reasons)\n--save specifies where this mirrorlist should be saved. pacman will check /etc/pacman.d/mirrorlist for the mirrorlist, so it makes sense to save it there.\nInstalling the base system # You will want to install the bare minimum just so that you can install and configure things properly inside of your actual operating system. You can this using the pacstrap command shown below:\npacstrap -K /mnt base base-devel linux linux-firmware nano intel-ucode mtools dosfstools networkmanager base is a minimal package set that defines a basic Arch Linux installation.\nbase-devel is a set of basic tools to build Arch Linux packages.\nlinux is the kernel itself.\nlinux-firmware is a set of firmware files to assist the Linux kernel.\nnano is a text editor, which will be used to edit configuration files later on. Feel free to replace this with vim, neovim or emacs if you are more familiar with those.\nintel-ucode provides low-level firmware updates for Intel CPUs to fix bugs, security vulnerabilities and strange behaviour. If you use an AMD CPU instead, replace this with amd-ucode.\nmtools allows you to access FAT filesystems. This is helpful for if you want to plug in any USB drive or SD cards in to your computer. FAT (or File Allocation Table) is a family of filesystems that are common on external storage devices - the most common of which is FAT32.\ndosfstools allows you to format and repair FAT filesystems.\nnetworkmanager allows you to connect to the internet and manages things like Wi-FI, ethernet, VPNs, mobile broadband modems, proxies .etc\nIf you formatted your root/home partition(s) to btrfs, append the below package to the command:\nbtrfs-progs btrfs-progs is a set of tools to help you manage btrfs filesystems on Linux.\nHowever, if you formatted yout root/home partition(s) to ext4, append the below package to the command:\ne2fsprogs It does the same things that btrfs-progs except for ext4 filesystems instead of btrfs filesystems.\nIf you connected to the internet via modemmanager, go ahead and append the below packages to the command:\nmodemmanager usb_modeswitch modemmanager allows you to connect the internet through a mobile broadband modem.\nusb_modeswitch fixes an annoying problem when handling with mobile broadband modems. With certain mobile broadband modems plugged into the computer via USB, Linux sometimes mistakens these as storage devices instead of modems. This package fixes that problem by teling the modem, \u0026ldquo;stop pretending to be a CD, go into modem mode\u0026rdquo;\nGenerating the fstab file # Warning\nThis step is CRUCIAL. If you forget to do this step, your Arch Linux system will not boot.\nArch Linux will not remember where you have mounted your partitions.\nTo make it remember, you will have to create an fstab file, which describes your drive\u0026rsquo;s partitions and where to mount them to on boot.\nThis is done with the following command:\ngenfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab Note\nA \u0026gt; will overwrite a file and a \u0026gt;\u0026gt; will append to a file. Make sure you don\u0026rsquo;t confuse these with each other\n","externalUrl":null,"permalink":"/arch-install-guide/pre-chroot-configuration/","section":"Arch Install Guide","summary":"Informs you on how to set up the mirrorlist, fstab file and how to install the bare minimum so that you can fully set up the operating system later","title":"Pre-chroot configuration","type":"arch-install-guide"},{"content":"Enter into the Arch Linux system by typing the below command:\narch-chroot /mnt Set the date and time # To see what timezones are available, run the below command:\n# ls /usr/share/zoneinfo/ Then, once you find your region, run the below command to narrow the timezone to cities\n# ls /usr/share/zoneinfo/\u0026lt;region\u0026gt; An example of a timezone path would be:\n/usr/share/zoneinfo/Europe/London Set the system\u0026rsquo;s timezone to yours by running the below command:\n# ln -sf /usr/share/zoneinfo/\u0026lt;region\u0026gt;/\u0026lt;city\u0026gt; /etc/localtime Then, synchronise the hardware clock with the system clock:\n# hwclock --systohc Set the locale and language # Open and edit the /etc/locale.gen file (as shown below):\n# nano /etc/locale.gen And then find your locale from the list shown on-screen.\nThis will be your two-letter language code, followed by a dash, then your two-letter country code, then a character set.\nThe following links will help you: https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes https://en.wikipedia.org/wiki/ISO_3166-2\nAn example of a locale would be:\n#en_US.UTF-8 UTF-8 Once you\u0026rsquo;ve found your locale, uncomment it. This would turn the above into the below:\nen_US.UTF-8 UTF-8 Save and quit (Ctrl+O then Enter then Ctrl+X)\nOnce all of this is done, let Arch Linux recognise them by running the below command:\nlocale-gen Then, open and edit the /etc/locale.conf file (as shown below):\n# nano /etc/locale.conf Add LANG= followed by the first part of your locale. So, given the above locale, add the following to the file:\nLANG=en_US.UTF-8 If your keyboard layout is not an American English keyboard, run the below command:\n# echo \u0026#34;KEYMAP=\u0026lt;your keymap\u0026gt;\u0026#34; \u0026gt; /etc/vconsole.conf For example, a British person would run the below command:\n# echo \u0026#34;KEYMAP=uk\u0026#34; \u0026gt; /etc/vconsole.conf Set the hostname # A hostname is what your computer identifies itself as when communicating to other computers. Set a hostname as shown below:\n# echo \u0026lt;hostname\u0026gt; \u0026gt; /etc/hostname You can set the hostname to whatever you like. Make sure you remember, because you\u0026rsquo;ll need to when editing the hosts file.\nEditing the hosts file # Open and edit the /etc/hosts file (as shown below):\n# nano /etc/hosts Add the below lines to it:\n127.0.0.1 localhost ::1 localhost 127.0.1.1 \u0026lt;your hostname\u0026gt;.localdomain \u0026lt;your hostname\u0026gt; Save and quit (Ctrl+O then Enter then Ctrl+X)\nThis step is important because a lot of programs tend to use localhost instead of 127.0.0.1. The above step just translates localhost into 127.0.0.1. localhost refers to the local machine on which a program is currently running on. It allows you to connect with services on the local machine\u0026rsquo;s network without having to connect to an outer network.\nEnable networkmananger # \u0026ldquo;Enabling\u0026rdquo; a service essentially means to configure it so that it runs automatically at boot.\nNetworkManager configures things like Wi-FI, ethernet, VPNs, mobile broadband modems, proxies .etc, so it would make sense to enable it.\nThis is done by running the below command:\n# systemctl enable NetworkManager Set the root password # Set a password for the root user so that your computer isn\u0026rsquo;t left wide open for cybercriminals to do as they please with your computer:\n# passwd If you have encrypted your root/home partition(s) If you have encrypted your root/home partition(s), you will need to configure Arch Linux\u0026rsquo;s boot process so that it will prompt you for your password to unlock them.\nTo do this, you will have to edit the mkinitcpio.conf file as shown below.\n# nano /etc/mkinitcpio.conf Find and comment out any line beginning with hooks (by adding a hashtag before it) and add the following line to the file:\nHOOKS=(base systemd autodetect microcode modconf kms keyboard keymap consolefont block encrypt lvm2 filesystems fsck) Save and quit (Ctrl+O then Enter then Ctrl+X).\\\nRegenerate the initcpio as shown below. The initcpio is a temporary root filesystem loaded by the kernel during the boot process before the real root filesystem is mounted.\nmkinitcpio -P Picking a bootloader # This guide will cover how to install three different bootloaders: systemd-boot, GRUB and rEFInd. If you are unsure, or haven\u0026rsquo;t bothered with encrypting your partitions and if you do not want to unify your kernel images, choose GRUB as your bootloader.\nGRUB is easily customisable, but a bit clunky and slow. You should select this option if you have encrypted your drive. It\u0026rsquo;s themeable, meaning you can make the bootloader look however you\u0026rsquo;d like it to.\nInstall GRUB Install GRUB as shown below:\n# pacman -S grub Then install GRUB (as shown below):\ngrub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB Then create a configuration file so that GRUB knows how to display the boot entries on your drive\ngrub-mkconfig -o /boot/grub/grub.cfg rEFInd has a pretty GUI and is good for multi-booting.\nInstall rEFInd Install rEFInd (as shown below):\n# pacman -S refind Create the configuration file (as shown below):\n# mkrlconf Edit the refind_linux.conf file (as shown below):\n# nano /boot/refind_linux.conf Delete the first two lines of the file by hitting Ctrl+K twice.\nThen save and exit (Ctrl+O then Enter then Ctrl+X).\nThen, edit the refind.conf file as shown below.\nnano /boot/EFI/BOOT/refind.conf Find the following line:\nmenuentry \u0026#34;Arch Linux\u0026#34; { Which can be found by hitting Ctrl + W and then entering the above line.\nEdit that section of the file such that:\nmenuentry \u0026#34;Arch Linux\u0026#34; { \u0026lt;...\u0026gt; options \u0026#34;root=PARTUUID=\u0026lt;...\u0026gt; rw add_efi_memmap\u0026#34; becomes:\nmenuentry \u0026#34;Arch Linux\u0026#34; { \u0026lt;...\u0026gt; options \u0026#34;root=label=root rw add_efi_memmap\u0026#34; Save and exit (Ctrl+O then Enter then Ctrl+X).\nsystemd-boot is lightweight and fast, it integrates well with your init system but installing and configuring it is quite involved. It\u0026rsquo;s also good if you want to unify your kernel images.\nInstall systemd-boot (optionally contains instructions on how to unify kernel images) Install systemd-boot (as shown below):\nbootctl install Create a unified kernel image (optional) Edit the loader.conf file (as shown below):\n# nano loader.conf Then make it so that the file only contains these lines:\ndefault arch-linux.efi timeout 5 console-mode keep default arch-linux.efi makes systemd-boot automatically boot to Arch Linux if you don\u0026rsquo;t select a boot entry.\ntimeout 5 stalls your system by 5 seconds before it boots so you have time to select an option. This is optional, and if you want an instant boot, you can leave it commented.\nconsole-mode keep keeps your console-based SystemD-Boot menu to how it was last time.\nSave and exit (Ctrl+O then Enter then Ctrl+X).\nThen, go and edit the linux.preset file as shown below\n# nano /etc/mkinitcpio.d/linux.preset Then edit the file so that the following are the contents of it:\n# mkinitcpio preset file for the \u0026#39;linux\u0026#39; package ALL_CONFIG=\u0026#34;/etc/mkinitcpio.conf\u0026#34; ALL_kver=\u0026#34;/boot/vmlinuz-linux\u0026#34; PRESETS=(\u0026#39;default\u0026#39; \u0026#39;fallback\u0026#39;) #default_config=\u0026#39;/etc/mkinitcpio.conf\u0026#39; #default_image=\u0026#39;/boot/initramfs-linux.img\u0026#39; default_uki=\u0026#34;/boot/EFI/Linux/arch-linux.efi\u0026#34; default_options=\u0026#34;--splash /usr/share/systemd/bootctl/splash-arch.bmp\u0026#34; #default_config=\u0026#39;/etc/mkinitcpio.conf\u0026#39; #default_image=\u0026#39;/boot/initramfs-linux-fallback.img\u0026#39; default_uki=\u0026#34;/boot/EFI/Linux/arch-linux-fallback.efi\u0026#34; default_options=\u0026#34;-S autodetect\u0026#34; Then, generate the unified kernel image as shown below:\nmkinitcpio -P Once you\u0026rsquo;re done with this, move on from this page of the guide. Following the sections below will cause your Arch Linux system to fail its boot process.\nEdit the loader.conf file (as shown below):\n# nano loader.conf Then make it so that the file only contains these lines:\ndefault arch.conf timeout 5 console-mode keep default arch.conf makes systemd-boot automatically boot to Arch Linux if you don\u0026rsquo;t select a boot entry.\ntimeout 5 stalls your system by 5 seconds before it boots so you have time to select an option. This is optional, and if you want an instant boot, you can leave it commented.\nconsole-mode keep keeps your console-based SystemD-Boot menu to how it was last time.\nChange directory into the entries folder, as shown below:\ncd entries/ Once you have done that, create a Arch Linux boot configuration file, as shown below:\nnano arch.conf Add the following lines to it:\ntitle Arch Linux linux /vmlinuz-linux initrd /initramfs-linux.img options root=label=root quiet rw title is what the boot option will display.\nlinux specifies where the Linux kernel image exists.\ninitrd specifies where your initramfs image exists.\\\noptions is a list of parameters to be sent to the kernel.\nSave and exit (Ctrl+O then Enter then Ctrl+X).\nNow, you need to create a boot configuration file for the fallback image, which is a initramfs that holds more modules and drivers, This exists because the default initramfs generated by mkinitcpio tries to include only what\u0026rsquo;s necessary for your specific hardware setup, using autodetection (e.g., filesystem, storage drivers). This keeps it small and fast. However, if something goes wrong, the fallback image comes in. It\u0026rsquo;s bloated on purpose, including every possible module and driver so it can boot in a broader range of situations.\nThis is done by simply copying the arch.conf file into a new arch-fb.conf file and then modifying arch-fb.conf in order to load the fallback initramfs instead of the regular one.\nFirstly, copy the arch-conf file into a new arch-fb.conf file\ncp /boot/loader/entries/arch.conf /boot/loader/entries/arch-fb.conf Then, edit the arch-fb.conf file:\nnano /boot/loader/entries/arch-fb.conf Change the file:\ntitle Arch Linux linux /vmlinuz-linux initrd /initramfs-linux.img options root=label=root quiet rw So that it looks like this:\ntitle Arch Linux linux /vmlinuz-linux initrd /initramfs-linux.img options root=label=root quiet rw Save and exit (Ctrl+O then Enter then Ctrl+X).\nWarning\nMake sure you have followed each instruction given above to a \u0026rsquo;t\u0026rsquo;.\nAny mistakes that you might make can and will cause Arch Linux to fail its boot sequence\n","externalUrl":null,"permalink":"/arch-install-guide/chroot-configuration/","section":"Arch Install Guide","summary":"Informs you on how to set the time, date, locale, language, root password and any user accounts","title":"Chroot configuration","type":"arch-install-guide"},{"content":"Now that Arch Linux has been fully installed on to your drive, it\u0026rsquo;s time to make it a comfortable desktop experience.\nTo do this, exit out of chroot, as shown below:\n# exit Then, reboot your computer:\n# reboot Once Arch Linux has booted, enter \u0026ldquo;root\u0026rdquo; as the username, and enter the root password when prompted.\\\nCreate a user account # Doing this is common sense, as many greeters do not allow you to login to your desktop as the root user. To do this, run the below command:\n# useradd -mG wheel \u0026lt;username\u0026gt; -m option creates a user directory for you, where local configurations and apps are stored. -G wheel creates the user as part of the wheel group, which will allow you to make changes on the system itself. For example, downloading and installing packages, and configuring them.\nSet a password for your user account (as shown below):\npasswd [username] Repeat the above process as many times as you want, depending on how many users you want to add to your system. If you do not want a user to make changes to the system, run the below command instead of the one shown above:\n# useradd -m \u0026lt;username\u0026gt; Allow the \u0026lsquo;wheel\u0026rsquo; group to make changes to the system # Open and edit the \u0026ldquo;sudoers\u0026rdquo; file (as shown below)\nEDITOR=nano visudo Find and uncomment the below line:\n# %wheel ALL=(ALL:ALL) ALL Save and quit (Ctrl+O then Enter then Ctrl+X).\nThen, log out of root:\nexit Re-connect to the internet # Note\nIf you normally connect to the internet via ethernet, you may skip this section.\nEnter the username for your user account and the password for it when prompted.\nOnce you have logged in, you must reconnect to the internet.\nThis is because the Arch ISO connected to the internet via iwd and the Arch installation connects to the internet through network-manager, which means that your network settings have been lost.\nIf you connected to the internet in the Arch ISO through a mobile broadband modem, the steps for connecting to the internet are the same as before. However, if you connected to the internet via a fixed broadband network, follow the steps shown below.\nFirstly, turn on Wi-Fi (as shown below):\n$ nmcli r wifi on And then list the access points that your computer can connect to:\n$ nmcli d wifi list Then, connect to the access point as shown below:\n$ nmcli d wifi connect \u0026lt;access point SSID\u0026gt; password \u0026lt;access point password\u0026gt; If your access point is not broadcasting its SSID, run the below command instead:\n$ nmcli d wifi connect \u0026lt;access point SSID\u0026gt; password \u0026lt;access point password\u0026gt; hidden yes ","externalUrl":null,"permalink":"/arch-install-guide/creating_and_login_into_a_user_account/","section":"Arch Install Guide","summary":"Informs you on how to install the programs that allow you to have a comfortable desktop experience and how to set up pacman and networking so that they can be used properly.","title":"Logging into your user account","type":"arch-install-guide"},{"content":" What is a window manager? # Put simply, a window manager organises your windows and decides how GUI elements are placed.\nThere are two main types of Window Managers (WMs):\nStacking Window Managers (SWMs) Tiling Window Managers (TWMs) An SWM is your vanilla window manager. You use your mouse to stack, arrange and rearrange windows. There\u0026rsquo;s normally a system tray, and a button to minimise all apps to it.\nA TWM is a bit more advanced tham an SWM. Their main focus is to increase productivity by keeping your hands on the keyboard.\n→ There\u0026rsquo;s keybinds for all functions, however, they have a much steeper learning curve.\nMy advice? # Use a stacking window manager if you use the Nano text editor, and use a tiling window manager if you use Vim, Neovim or Emacs.\nDifferent SWMs # This section will cover Stacking Window Managers.\nKDE Plasma To just install KDE Plasma, use the below command:\n# pacman -S plasma The packages below provide a more integrated desktop experience for KDE Plasma\n# pacman -S konsole dolphin ark kwrite kcalc spectacle krunner partitionmanager Packages Description plasma KDE Plasma window manager. konsole Terminal. dolphin File manager. ark Archiving Tool. kwrite Text editor. kcalc Scientific calculator. spectacle Screenshot capture utility. krunner Quick drop-down desktop search. partitionmanager Disk \u0026amp; partition manager. GNOME To install GNOME, use the below command:\n# pacman -S gnome gnome-extra gnome-extra is for a more integrated desktop experience, and includes a bundle of apps to facilitate that.\nEnlightenment Install Enlightenment, as shown below:\n# pacman -S enlightenment ecrire ephoto evisum rage terminology The packages that aren\u0026rsquo;t enlightenment provide a more integrated desktop environment.\nPackages Description enlightenment Enlightenment window manager terminology Terminal ecrire Text editor evisum Process viewer, similar to Task Manager on Windows ephoto Photo viewer rage Video viewer \u003e Note: Wayland support on LXQt and XFCE is a bit shaky. LXQt To install LXQt, use the below command:\n# pacman -S lxqt XFCE To install XFCE, use the below command:\n# pacman -S xfce xfce4-goodies xfce4-goodies is for a more integrated desktop experience, and includes a bundle of apps to facilitate that.\nDifferent TWMs # Images used are meant to demonstrate their customisability and do not reflect what they look like out-of-the-box.\nHyprland To install hyprland, use the below command:\n# pacman -S hyprland Niri Install Niri, as shown below:\n# pacman -S niri Sway Install Sway, as shown below:\n# pacman -S sway swaylock swaybg swayidle river To install river, use the below command:\n# pacman -S river Installing a display manager # Now that you have installed a window manager, you will need to install a display manager.\nThere are two main greeters in Arch Linux: sddm and gdm.\nIf you have installed GNOME as your desktop environment, install and enable GDM as shown below:\n# pacman -S gdm # systemctl enable gdm.service If you have installed any other window manager, install and enable SDDM as shown below:\n# pacman -S sddm # systemctl enable sddm.service Setting up sound on Linux # Note\nThis step is optional, but allows you to enjoy bluetooth and configuring sound devices on your computer.\nBelow is a command that installs a bunch of applications somewhat relating to sound\n# pacman -S alsa-utils bluez bluez-utils pipewire wireplumber pipewire-alsa pipewire-pulse Packages Description alsa-utils Allows you to configure sound devices in the terminal bluez Provides bluetooth functionality bluez-utils Allows you to configure bluetooth in the terminal pipewire Audio and video server for Linux. Allows you to screen-capture and provides desktop sound wireplumbler Tells PipeWire what to do with audio and video devices pipewire-alsa Provides sound drivers pipewire-pulse A compatibility layer that allows legacy PulseAudio apps to work on PipeWire Then, enable bluetooth, as shown below:\n# pacman -S bluetooth.service If at any point, you experience sound issues when running Wine applications, you may need to install an audio driver package as shown below:\n# pacman -Syu lib32-alsa-lib lib32-alsa-plugins lib32-pipewire Now, installation is fully complete. For some quality-of-life features, check out the extras page.\nTo enjoy graphics on Arch, run the below command:\n$ reboot ","externalUrl":null,"permalink":"/arch-install-guide/window_and_display_managers/","section":"Arch Install Guide","summary":"Informs you on how to choose and install a window manager and a display manager","title":"Window and display managers","type":"arch-install-guide"},{"content":" Apps I would recommend installing # # pacman -S git openssh fastfetch lib32-mesa wine vlc audacious cups openssh tmux Packages Description openssh* Secure Shell access server, allows you to access remote computers or servers. audacious Music player. wget* Wget is a free utility for non-interactive download of files from the Web. tmux A program that allows you to have multiple programs running in one terminal window. git* Allows you to interact with git repositories (needed to access the AUR) fastfetch Fastfetch is a command-line system information tool, that is the sucessor to NeoFetch. Used by Arch users to flex the fact that they have installed Arch. cups* Allows you to use printers wine* Compatibility layer for Windows applications. Proton needs this application in order to run most Steam games lib32-mesa* Allows you to run old 3D games on Steam Note\nThe programs marked wtih asterisks are some of the more important packages, which a lot of programs tend to rely on in order to work. It is highly recommended to install them.\nEnable OpenSSH daemon and CUPS printer service # # systemctl enable sshd.service # systemctl enable --now cups.service Installing Vulkan and OpenGL drivers # For pretty much any game to work, you need an OpenGL and a Vulkan driver. Check your GPU driver for the OpenGL and Vulkan drivers below:\nGPU driver OpenGL driver Vulkan driver xf86-video-intel mesa \u0026amp; lib32-mesa vulkan-intel \u0026amp; lib32-vulkan-intel xf86-video-amdgpu mesa \u0026amp; lib32-mesa vulkan-radeon \u0026amp; lib32-vulkan-radeon xf86-video-ati mesa \u0026amp; lib32-mesa (N/A) xf86-video-nouveau mesa \u0026amp; lib32-mesa vulkan-nouveau \u0026amp; lib32-vulkan-nouveau nvidia or nvidia-open nvidia-utils \u0026amp; lib32-nvidia-utils (Same as OpenGL drivers) Note\nYou\u0026rsquo;ll want to install both the multilib (prefixed with lib32-*) and non-multilib drivers to ensure compatibility. Additionally, the drivers are listed by their name in the Arch Linux repositories - all the packages listed above can be installed as they are named above.\nInstalling an AUR helper # Most programs that run on Arch are found in the Arch User Repository. These are things like VS Code or the Brave browser.\nTo install programs from the AUR conveniently, you\u0026rsquo;ll need to install an AUR helper. There are two good AUR helpers: yay and paru.\nyay is great if you want a fast, no-fuss AUR helper.\nparu is better if you value safety, polish, and a nicer interface.\nInstalling paru In order to install paru, you will need to have install base-devel. Ensure it is install by running the below command:\n# pacman -S --needed base-devel Then, install paru as shown below:\n$ git clone https://aur.archlinux.org/paru.git \u0026amp;\u0026amp; cd paru \u0026amp;\u0026amp; makepkg -si A guide on how to use paru can be found by running the below command:\nman paru And:\nman paru.conf Installing yay In order to install yay, you will need to have install base-devel. Ensure it is install by running the below command:\n# pacman -S --needed base-devel Then, install yay as shown below:\n$ git clone https://aur.archlinux.org/yay.git \u0026amp;\u0026amp; cd yay \u0026amp;\u0026amp; makepkg -si A guide on how to use yay can be found here\nEnabling secure boot # Secure Boot is a security standard designed to ensure that a device boots using only trusted software.\nTo enable it, go into your firmware settings and erase all of your secure boot keys. How to do so depends on your computer\u0026rsquo;s manufacturer.\nOnce you\u0026rsquo;ve done that, install sbctl by running the below command:\n# pacman -S sbctl Then create secure boot keys by running the below command:\n# sbctl create-keys Then enroll those keys, alongside Microsoft\u0026rsquo;s, to the UEFI\n# sbctl enroll-keys -m Check what files need to be signed by running:\n# sbctl verify If you have unified your kernel images, simply run the below command:\n# sbctl sign -s /boot/EFI/Linux/arch-linux.efi # sbctl sign -s /boot/EFI/Linux/arch-linux-fallback.efi # sbctl sign -s /efi/EFI/BOOT/BOOTX64.EFI If you haven\u0026rsquo;t, then run the below commands instead:\n# sbctl sign -s /boot/vmlinuz-linux # sbctl sign -s /boot/EFI/Boot/bootx64.efi # sbctl sign -s /boot/EFI/systemd/systemd-bootx64.efi Alternative shells # The shell that comes with your system automatically is bash. However, bash isn\u0026rsquo;t very good. To fix that, you can use an alternative shell. Some will be listed below:\nzsh is fully backwards compatible with bash, and is highly configurable shell. However, it has quite a learning curve.\nfish is an easy-to-learn and highly configurable shell. It has features like autosuggestions out of the box. However, if you\u0026rsquo;re used to bash or zsh, it might take some time to learn fish.\nTo see what shell you have as default (this will likely be bash), run the below command:\necho $SHELL To see what shells you have installed on your system, run the below command:\nchsh -l Find the shell of your preference within that list and change it accordingly using the below command:\nchsh -s \u0026lt;shell\u0026gt; Replacing \u0026lt;shell\u0026gt; with the shell of your preference. An example can be found below.\nchsh -s /usr/bin/fish ","externalUrl":null,"permalink":"/arch-install-guide/extras/","section":"Arch Install Guide","summary":"Informs you on different applications you can install/configure to make your Arch Linux experience more comfortable","title":"Extras","type":"arch-install-guide"},{"content":"","date":"21 June 2025","externalUrl":null,"permalink":"/","section":"The Cove of Bahmoudd","summary":"","title":"The Cove of Bahmoudd","type":"page"},{"content":" As you all may know, Wayland has existed for 20-ish years and is still incomplete. Take, for example, accessibility. On-screen keyboards, for example, are pretty difficult to set up on Wayland compositors, to put it lightly.\nThe direction freedesktop is taking with Wayland is not the direction most people want regular display protocols to take. Many projects like Flatpak and Appimage try to unify the Linux desktop by providing a common packaging format that is compatible amongst most distros (well, the distros that people actually use, of course).\nBy leaving pretty much everything to the compositor, like important functionality such as managing refresh rates, managing multiple monitors, setting specific resolutions .etc, this means that developers who want to make desktop environments have to write more boilerplate to get basic functionality out of the display server. Since distros are more likely to prefer one desktop environment over another, this means that basic things like setting resolution will be different from one distro to another. What the fuck, Wayland? This is going against many developers\u0026rsquo; efforts to unify the Linux desktop.\nSince there\u0026rsquo;s no simple command to change basic things, beginners will have to enter rabbit holes in order to find the one command that allows them to do things. Hence, why the \u0026ldquo;year of the Linux desktop\u0026rdquo; is being placed out of the reach of Linux users because of freedesktop.\nThe people that worked on X11 now work on Wayland. So, freedesktop has been trying to kill Wayland for some time now. Project developers killing good things is not what I signed up for when switching to Linux - it\u0026rsquo;s exactly why I\u0026rsquo;m phasing Microsoft out of my life.\nBy forking X11 and creating Xlibre, Enrico Weigelt is essentially preserving the essence of the FOSS world - if a project dies out, fork it, and if that fork dies, fork that one and so on.\nX11 was itself a fork of Xfree86. Xfree86 was forked because the people actually doing work on the project were being fucked over by the fellas leading the Xfree86 project. Now the same thing is happening between freedesktop and Weigelt. Refer to the image below.\nThis \u0026ldquo;you will own nothing and you will be happy\u0026rdquo; mentality is not what I signed up for when installing Linux. Weigelt forking the X.org project is honestly doing the work that probably should have been done some time ago.\nChanging the topic slightly, whilst I\u0026rsquo;m not a fan of Wayland, I\u0026rsquo;m pretty much forced to use it. Most drivers and new software is only gonna work on Wayland, and this is only going to get worse later on. Forking X11 is the first step in producing a usuable Linux desktop space. Now all we need is people to start making software and shit for X now, which might or might not happen. Only time will tell.\n","date":"21 June 2025","externalUrl":null,"permalink":"/posts/xlibre/","section":"Posts","summary":"A discussion about Xlibre and Wayland, and why a fork of X.org is so desparately needed","title":"Xlibre is the FOSS world in action","type":"posts"},{"content":"","date":"27 April 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" What will this site be about # This site is essentially a side project for me to record my thoughts about stuff, which will mostly be about tech and the FOSS world. This site may contain unpopular or controversial opinions, so if you\u0026rsquo;re a person who can\u0026rsquo;t cope with that and call everything you disagree with \u0026ldquo;ragebait\u0026rdquo;, then kindly click off my site. Also, this site will not be a place for tech news, but rather provide commentary on what happens in the tech world, so please don\u0026rsquo;t treat this site as such, as I want everyone to have an informed view of the tech world, instead of just listening to my one-sided two cents on it.\n","date":"27 April 2025","externalUrl":null,"permalink":"/posts/initial_post/","section":"Posts","summary":"A list of things that will go over what I may post in my site, and what people can expect to see here","title":"Initial post","type":"posts"},{"content":"","externalUrl":null,"permalink":"/arch-install-guide/glossary/access-point/","section":"Arch Install Guide","summary":"","title":"","type":"arch-install-guide"},{"content":"","externalUrl":null,"permalink":"/arch-install-guide/glossary/firmware/","section":"Arch Install Guide","summary":"","title":"","type":"arch-install-guide"},{"content":"","externalUrl":null,"permalink":"/arch-install-guide/glossary/initramfs/","section":"Arch Install Guide","summary":"","title":"","type":"arch-install-guide"},{"content":"","externalUrl":null,"permalink":"/arch-install-guide/glossary/network/","section":"Arch Install Guide","summary":"","title":"","type":"arch-install-guide"},{"content":"","externalUrl":null,"permalink":"/arch-install-guide/glossary/repository/","section":"Arch Install Guide","summary":"","title":"","type":"arch-install-guide"},{"content":"","externalUrl":null,"permalink":"/arch-install-guide/glossary/ssid/","section":"Arch Install Guide","summary":"","title":"","type":"arch-install-guide"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"The bootloader is a small program that runs after your system firmware (UEFI or BIOS) and before your operating system. Its job is to load the kernel of the OS into memory and start it. An example of this is GRUB.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/boatloader/","section":"Arch Install Guide","summary":"","title":"bootloader","type":"arch-install-guide"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"A compatibility layer is a piece of software that converts an interaction between Software A and Software B into an interaction between Software A and Software C. Wine is an example of a compatibility layer, because it translate Windows NT kernel calls into Linux kernel calls.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/compatibility-layer/","section":"Arch Install Guide","summary":"","title":"compatibility-layer","type":"arch-install-guide"},{"content":"Compilation is the act of turning source code into machine code.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/compilation/","section":"Arch Install Guide","summary":"","title":"compilation","type":"arch-install-guide"},{"content":"A \u0026ldquo;distro\u0026rdquo; (or Linux distribution) is a bundle of software including a fully-configured copy of the Linux kernel, and other software which allow applications to run. For example, Arch Linux is a distro that comes bundled with the GNU software collection, systemd, and pacman.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/distro/","section":"Arch Install Guide","summary":"","title":"distro","type":"arch-install-guide"},{"content":"A filesystem is a set of rules as to how files should be organised and accessed on a partition - this usually deletes everything on that partition (if there\u0026rsquo;s anything on there to begin with). Think of the partition as a piece of paper. Formatting is like drawing the guide lines, margin and setting the page layout so you can write inside of it properly, of course, for the piece of paper to be useful, everything on it needs to be rubbed out before you can do so.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/filesystem/","section":"Arch Install Guide","summary":"","title":"filesystem","type":"arch-install-guide"},{"content":"To format a partition means to prepare it for storing files by creating a filesystem on it.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/format/","section":"Arch Install Guide","summary":"","title":"format","type":"arch-install-guide"},{"content":"GNU, is a collection of software that allows you to fully interact with your computer. Linux was created after GNU as it has no kernel, which is essential for a computer to run.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/gnu/","section":"Arch Install Guide","summary":"","title":"gnu","type":"arch-install-guide"},{"content":"A greeter is the login screen. It asks for a username and password so that you can then access your desktop. It is provided by the display manager, which is responsible for starting the graphics server. The graphics server is responsible for managing graphical elements on your computer, like drawing windows.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/greeter/","section":"Arch Install Guide","summary":"","title":"greeter","type":"arch-install-guide"},{"content":"An init process is the first process your computer loads when powering on. It is the parent of all processes - it sets them up and manages them. It does things like running background processes, configures hardware et cetera, and makes sure that the computer has come to the state where it\u0026rsquo;s ready for you to use. It stays running the entire time that your computer is on, managing processes as I have stated before and handling errors if they crash. Arch Linux uses systemd, which is an entire suite of software, not just an init system, doing things such as logging and networking. It\u0026rsquo;s easy to manage as everything is in one place, and provides fast boot-up times.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/init/","section":"Arch Install Guide","summary":"","title":"init","type":"arch-install-guide"},{"content":"An iso file is, generally speaking, an \u0026ldquo;image\u0026rdquo; (or snapshot) of what would be written to something like a CD or drive. However, within the context of this guide, an ISO file is a single file that contains all the data needed to install an operating system. Arch Linux is installed using a live ISO, meaning that the operating system that boots from it is a complete and fully-functional operating system. However, this is only used as an intermediate stage to get Arch Linux installed on to your drive.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/iso/","section":"Arch Install Guide","summary":"","title":"iso file","type":"arch-install-guide"},{"content":"A kernel is the middleman between programs and hardware. An example of this is the NT kernel, which is what Windows uses.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/kernel/","section":"Arch Install Guide","summary":"","title":"kernel","type":"arch-install-guide"},{"content":"Linux is a Unix-like kernel released in 1991 by Linus Torvalds.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/linux/","section":"Arch Install Guide","summary":"","title":"linux","type":"arch-install-guide"},{"content":"Machine code (also known as a \u0026lsquo;binary executable\u0026rsquo;, or just \u0026lsquo;binary\u0026rsquo;) is what computers can actually understand and run (or \u0026ldquo;execute\u0026rdquo;).\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/machine-code/","section":"Arch Install Guide","summary":"","title":"machine code","type":"arch-install-guide"},{"content":"A mirror is essentially a duplicate copy of some data on a master server (a server that the data was originally uploaded on). Mirrors are kept for two reasons, to have a copy in case something goes wrong on the master server (or, \u0026ldquo;redundancy\u0026rdquo;) and speed. Mirrors are set up on Linux distros to make download speeds faster, because, put simply, the closer you are to a server, the less time it takes to upload and download data. This is why the mirrorlist exists, as really slow download speeds can time out, meaning that your computer will give up after some period of waiting.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/mirror/","section":"Arch Install Guide","summary":"","title":"mirror","type":"arch-install-guide"},{"content":"A package manager is a collection of software that automates the process of installing, updating and deleting software on a computer in a consistent manner. Arch Linux uses pacman (not to be confused with the \u0026rsquo;80s arcade game) which is a rolling release package manager, meaning that software is not released as regular, big updates every once in a while, but rather, small and continuous updates delivered frequently.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/package-manager/","section":"Arch Install Guide","summary":"","title":"package manager","type":"arch-install-guide"},{"content":"A partition is an explicitly defined section of your drive. Each partition on your computer can be managed separately, meaning all of the data on one partition is completely different from the data on another. This is useful for keeping data crucial for your system to run from other data like documents.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/partition/","section":"Arch Install Guide","summary":"","title":"partition","type":"arch-install-guide"},{"content":"Not to be confused with the root user. The root directory is the furthest back in a file structure you can go. It is where all the branches created from files and folders on your computer originate from. It holds important folders such as /boot/ and /home/.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/root-directory/","section":"Arch Install Guide","summary":"","title":"root directory","type":"arch-install-guide"},{"content":"Not to be confused with the root directory. The root user is the most powerful user on your computer capable of performing any task with zero restrictions. Regular users can\u0026rsquo;t and shouldn\u0026rsquo;t be able to run everything as root, because it\u0026rsquo;s too easy to, for example, delete something important that is essential for your OS to function. This is why it\u0026rsquo;s good practice to make a user separate from the root user, and add a password to it so you think more about what you type in to your shell.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/root-user/","section":"Arch Install Guide","summary":"","title":"root user","type":"arch-install-guide"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"The shell is the text interface that allows you to interact with your computer that surrounds the kernel to hide its intricate details.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/shell/","section":"Arch Install Guide","summary":"","title":"shell","type":"arch-install-guide"},{"content":"A signature (or a \u0026lsquo;hash signature\u0026rsquo;, or just \u0026lsquo;hash\u0026rsquo;) is a random string of letters assigned to a file that serves as its unique digital fingerprint. A good hashing algorithm (such as SHA-256) produces a unique string of letters for each input it is given, if they are different. This means that it is impossible for a file to be tampered with without producing an extremely different hash. This is why it is important to check the signature of each file you download off the internet with the one given by the software\u0026rsquo;s publisher.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/signature/","section":"Arch Install Guide","summary":"","title":"signature","type":"arch-install-guide"},{"content":"Source code is what computer programmers write to make computers do things. It needs to be converted into machine code before it can be run (or \u0026ldquo;executed\u0026rdquo;). Programs can either be distributed as source code, meaning that the user has to compile it themselves, or they can be distributed as machine code where no compilation is needed. Both approaches have their upsides and downsides. Source code distributions means that the user has to compile the code, meaning that your program suddenly has a learning curve attached to it. Machine code distributions mean that your program now only works for one kind of machine and operating system (for example, if you compile your program on an x64 Linux machine, the machine code binary will only work other x64 Linux machines).\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/source-code/","section":"Arch Install Guide","summary":"","title":"source code","type":"arch-install-guide"},{"content":"Linux swap is either a file or partition on your drive. It is used as a section of your disk that can store data in RAM even when the computer is off (for hibernation, which is important for laptop users) or be used in case RAM runs out. Even if you are not on a laptop and have a sufficient amount of RAM, some programs rely solely on swap, so make create swap space regardless. This guide will not create a swapfile, but rather, a swap partition to keep the swap data separate from everything else.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/swap/","section":"Arch Install Guide","summary":"","title":"swap","type":"arch-install-guide"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"Unix is an operating system family that started off at AT\u0026amp;T. It became very influential within academic circles, leading to large-scale adoption by start-up companies, leading Unix to fragment into much smaller, similar but mostly mutually incompatible OSes. Among these are MacOS and the BSD operating systems (FreeBSD, OpenBSD, NetBSD .etc). An operating system is said to be Unix-like if it behaves like a Unix operating system. For this reason, Linux is generally considered to be Unix-like. The reason why Linux is Unix-like and not Unix is because it is commonly paired with GNU, which stands for \u0026ldquo;GNU\u0026rsquo;s Not Unix\u0026rdquo;.\n","externalUrl":null,"permalink":"/arch-install-guide/glossary/unix-like/","section":"Arch Install Guide","summary":"","title":"unix-like","type":"arch-install-guide"}]